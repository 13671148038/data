为了解释List数据类型，最好从一点理论开始，因为术语List经常被信息技术人员以不正确的方式使用。

例如，“Python Lists”不是名称可能提示的（链接列表），而是数组（相同的数据类型在Ruby中实际上称为Array）。

从一般观点来看，List只是一个有序元素序列：10,20,1,2,3是一个列表。但是使用数组实现的List的属性与使用链接列表实现的List的属性非常不同 。

Redis列表通过链接列表实现。这意味着，即使列表中有数百万个元素，在头部或尾部添加新元素的操作也会在不变的时间内执行。

使用LPUSH命令将新元素添加到具有十个元素的列表头部的速度与将元素添加到具有一千万个元素的列表头部的速度相同。

缺点是什么？通过索引访问元素在使用Array（恒定时间索引访问）实现的列表中速度非常快，而在由链接列表实现的列表中速度并不那么快（操作需要的工作量与访问元素的索引成比例）。

Redis列表是用链表实现的，因为对于数据库系统来说，能够以非常快速的方式将元素添加到很长的列表是非常重要的。

正如您稍后会看到的，另一个强大的优势是Redis列表可以在恒定时间内保持恒定长度。

当快速访问大量元素集合的中间部分很重要时，可以使用不同的数据结构，称为排序集合。排序集将在本教程后面介绍。


	1. rpush mylist A   //在列表的右侧就是尾部添加元素
	2. lpush mylist b   //在列表的左侧就是头部添加元素

	3. lrange mylist 0 -1  //LRANGE命令从列表中提取元素的范围：请注意，LRANGE需要两个索引，范围的第一个和最后一个元素返回。
        两个索引都可以是负数，告诉Redis从头开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素，依此类推。
	
	4. rpush mylist 1 2 3 4 5 "foo bar"   //一次添加多个原色

        5. rpop mylist                        //右侧也就是末尾处弹出列表的元素.
	6. lpop mylist                        //左侧也就是头部处弹出列表的元素.如果没有值返回null(nil)


列表的常见用例
列表对于许多任务很有用，下面是两个非常具有代表性的用例：
  记住用户发布到社交网络的最新更新。
  进程之间的通信，使用消费者 - 生产者模式，生产者将项目推入列表中，消费者（通常是工作者）使用这些项目并执行操作。Redis有特殊的列表命令，使这个用例更加可靠和高效。


例如，为了实现后台作业，流行的Ruby库resque和 sidekiq都使用了Redis列表。

流行的Twitter社交网络将 用户发布的最新推文发布到Redis列表中。

要逐步描述常见用例，假设您的主页显示在照片共享社交网络中发布的最新照片，并且您希望加快访问速度。

每次用户发布新照片时，我们都会使用LPUSH将其ID添加到列表中。
当用户访问主页时，我们使用这些信息LRANGE 0 9来获取最新的10个发布项目。




封顶列表
在许多用例中，我们只是想使用列表来存储最新的项目，无论它们是什么：社交网络更新，日志或其他任何内容。

Redis允许我们使用列表作为上限集合，只记住最新的N个项目，并使用LTRIM命令丢弃所有最旧的项目。

的ltrim 命令类似于lrange，但是，而不是显示元件的指定范围它设置在该范围作为新的列表值。给定范围之外的所有元素都将被删除。

   ltrim mylist 0 2     //给定范围之外的所有元素都将被删除。





阻止列表中的操作
列表有一个特殊的功能，使它们适合实现队列，并且通常作为进程间通信系统的构建块：阻塞操作。

想象一下，你想用一个进程将项目推入一个列表，并使用一个不同的进程来实际完成这些项目的某种工作。这是通常的生产者/消费者设置，可以通过以下简单的方式实现：

为了将物品推入列表中，生产者调用LPUSH。
为了从列表中提取/处理项目，消费者需要调用RPOP。
但是有时列表可能是空的，没有任何可处理的内容，所以RPOP只返回NULL。在这种情况下，消费者被迫等待一段时间，然后再次使用RPOP重试。这称为轮询，在这种情况下不是一个好主意，因为它有几个缺点：

强制Redis和客户端处理无用的命令（当列表为空时的所有请求都不会完成实际的工作，它们只会返回NULL）。
为项目处理添加延迟，因为在工作人员收到NULL之后，它会等待一段时间。为了使延迟更小，我们可以在rpop的调用之间等待较少的时间，从而放大问题1，即对Redis进行更多无用的调用。
所以Redis的实现称为命令BRPOP和BLPOP它们的版本RPOP和LPOP能够阻止如果列表是空的：他们将回到只有当新的元素添加到列表中，或者当用户指定超时主叫到达。

这是我们可以在工作人员中使用的BRPOP呼叫的示例：

    brpop tasks 5  //从列表tasks中弹出元素,如果列表中没有元素则会等待5秒钟,  如果后面的数字为0 则表示一直等待



自动创建和删除密钥
到目前为止，在我们的示例中，我们从不必在推送元素之前创建空列表，或者在内部不再有元素时删除空列表。Redis有责任在列表为空时删除密钥，或者在密钥不存在的情况下创建一个空列表，并尝试向其添加元素（例如，使用LPUSH）。

这不是特定于列表的，它适用于由多个元素组成的所有Redis数据类型 - 集合，排序集合和散列。

基本上我们可以用三条规则来总结行为：

当我们向一个聚合数据类型添加一个元素时，如果目标关键字不存在，在添加元素之前创建一个空的聚合数据类型。
当我们从集合数据类型中移除元素时，如果值保持为空，则该键自动销毁。
调用诸如LLEN（它返回列表长度）的只读命令或用空键删除元素的写命令总是产生相同的结果，就好像该键持有类型为空的聚合类型命令期望找到。

llen mylist 返回列表的长度















